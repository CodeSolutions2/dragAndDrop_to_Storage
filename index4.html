<!DOCTYPE html>
<html>
<head></head>
<body>

<h1>Multimedia fetch data webapp</h1>
<ol type="A">
	<li>Enter URL.</li>
	<ul>
		<li>https://nominatim.openstreetmap.org/search?q=LOCATION_NAME&format=json</li>
		<li>https://api.open-meteo.com/v1/forecast?latitude=LATITUDE&longitude=LONGITUDE&hourly=temperature_2m</li>
		<li>https://raw.githubusercontent.com/CodeSolutions2/pdf_to_text_webapp/main/document_imagepdf.pdf</li>
		<!-- <li>https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf</li> -->
		<li>https://storage.googleapis.com/on-the-way2selfrespect/yellow.png</li>
	</ul>
	<li>method: 'GET', 'POST'</li>
	<li>data: {}</li>
  	<li>w_or_wo_proxyhandler: w_proxyhandler, wo_proxyhandler</li>
	<li>return_type: json, blob, blob_file_pdf, arrayBuffer, text</li>
	
</ol>
	
<input id="url" type="text" value="" placeholder="url" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="method" type="text" value="" placeholder="method" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="data" type="text" value="" placeholder="data" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="w_or_wo_proxyhandler" type="text" value="" placeholder="w_or_wo_proxyhandler" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="return_type" type="text" value="" placeholder="return_type" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">

<button id="script_CORS_GET" onclick="script_CORS_GET()">script_CORS_GET</button>
	
<button id="run_fetch_CORS" onclick="run_fetch_CORS()">run_fetch_CORS</button>
	
<button id="run_jQuery_CORS" onclick="run_jQuery_CORS()">run_jQuery_CORS</button>

<button id="run_Image_CORS" onclick="run_Image_CORS()">run_Image_CORS</button>

<button id="get_forecast_temperature_data" onclick="get_forecast_temperature_data()">get_forecast_temperature_data</button>
	
	
<!-- <script src='https://code.jquery.com/jquery-3.6.3.min.js'></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script>
	
// -----------------------------------------------
	
window.addEventListener('beforeunload', function() {
    window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});
	
// -----------------------------------------------

async function run_fetch_CORS() {

	var url = document.getElementById('url').value;  // url: url address
	var method = document.getElementById('method').value;  // method: 'GET', 'POST'
	var data = document.getElementById('data').value;  // data: required data format for url address
	var w_or_wo_proxyhandler = document.getElementById('w_or_wo_proxyhandler').value;  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	var return_type = document.getElementById('return_type').value;  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'

	var data = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('data: ', data); 
}

// -----------------------------------------------

async function run_jQuery_CORS() {

	var url = document.getElementById('url').value;  // url: url address
	var method = document.getElementById('method').value;  // method: 'GET', 'POST', 'PUT'
	var data = document.getElementById('data').value;  // data: required data format for url address
	var return_type = document.getElementById('return_type').value;  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'

	var data = await  jQuery_CORS(url, method, data, return_type);
	console.log('data: ', data); 
}
	

// -----------------------------------------------

async function run_Image_CORS() {
	var canvasElement = document.createElement('canvas');
	var ctx = canvasElement.getContext("2d");
	var canvasElement_width = 150;
	var canvasElement_height = canvasElement_width;
	
	const imageElement = new Image();  // image is 'HTMLImageElement'
	imageElement.setAttribute('crossOrigin', "");
	imageElement.setAttribute('headers', {"Content-Type": "application/json", "Access-Control-Allow-Origin": "*"});
	imageElement.src = url;
	imageElement.onload = async () => { ctx.drawImage(imageElement, 0, 0, canvasElement_width, canvasElement_height); };

	const imageData = ctx.getImageData(0, 0, canvasElement_width, canvasElement_height);
	const pixelData = Array.from(imageData.data);
	console.log('pixelData: ', pixelData); 
	
	document.getElementsByTagName('body')[0].appendChild(canvasElement);
}
	
// -----------------------------------------------
	
async function get_forecast_temperature_data(url) {
	
	// [Step 0] Get latitude and longitude
	var url = 'https://nominatim.openstreetmap.org/search?q=Lyon&format=json';
	var method = 'GET';  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	var return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	var out = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('out: ', out); 

	// --------------------------------

	var latitude = out[0].lat;
	var longitude = out[0].lon;
	console.log("latitude: ", latitude);
	console.log("longitude: ", longitude);

	// [Step 0] Get weather data
	// https://open-meteo.com/en/docs
	// The API endpoint /v1/forecast accepts a geographical coordinate, a list of weather variables and responds with a JSON hourly weather forecast for 7 days. Time always starts at 0:00 today and contains 168 hours. If &forecast_days=16 is set, up to 16 days of forecast can be returned. All URL parameters are listed below:

	url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m`;
	
	method = 'GET';  // method: 'GET', 'POST'
	w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	out = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('out: ', out);
	
}

// -----------------------------------------------
	

	

// -----------------------------------------------
// SUBFUNCTIONS
// -----------------------------------------------


// [Step 0] create the script element
const scriptElement = document.createElement('script');
scriptElement.type="application/json"; // "text/javascript";
scriptElement.crossorigin="*";
scriptElement.redirect="follow";
scriptElement.mode='cors';

var headers = {
	"Content-Type": "application/json",
	"Connection": "keep-alive",
	"Access-Control-Allow-Origin": "*",
};
scriptElement.headers = new Headers(headers);
console.log('[Step 0] create the script element');

	
var response;  // response is the output of running scriptElement.src



	
// This is like a template for how to use the callback with the called function
async function script_method(url, callback) {
	
	// [Step 1] Run/call the script with a callback
	console.log('[Step 1] Run/call the script with a callback');
	// This does not run/call the callback, it just assigns the callback to run the function func_callback
	// The ? starts a query, and should only be used once; there is already a ? in the url so we add callback on using &
	// The & separates value-pairs
	scriptElement.src = `${url}&callback=${callback}`;
	
	// The robot says that the assignment of scriptElement.src = `${url}&callback=callback`; causes the callback to run.

	// Where is the output of the ran command 'scriptElement.src'?

	// after the assignment of scriptElement.src = `${url}&callback=callback` such that the callback runs, how does 


	
	// [Step 2] Get the output from running scriptElement.src
	console.log('[Step 2] Get the output from running scriptElement.src')

	// --------------------------------
	
	// Way 0: Basic method to call a callback
	// Problems:
	// 0) where does response come from? response is the output of running scriptElement.src.
	// 1) this has nothing to do with the callback that is defined in scriptElement.src? Yes, it does because running scriptElement.src caused the callback to return the output
	
	// var data_out = await new Promise(resolve => { var data = resolve(callback(response)); return data; });
	// console.log('data_out: ', data_out); 
	
	// RESULT: gives an error because scriptElement.src does not return the response to the callback
	

	// Way 0b: Add a pause before resolving the callback
	// Problems:
	// 0) here does data come from?
	// 1) this has nothing to do with the callback that is defined in scriptElement.src
	// var data_out = new Promise(resolve => { setTimeout(resolve, 2000); resolve(callback(data)); });
	// console.log('data_out: ', data_out); 

	// --------------------------------
	
	// Way 1: create a proxy, handler
	// Problems:
	// 0) where does response come from? response is the output of running scriptElement.src.
	var callback_name = callback.name;
	window[callback_name] = function(response) { 
		document.body.appendChild(scriptElement);
		console.log('response: ', response);
		return new Promise(resolve => { var data = resolve(callback.call((window), response)); return data; });
	}
	console.log('window[callback_name]: ', window[callback_name]);

	console.log('callback_name: ', callback_name);
	
	// --------------------------------
	
	// Way 3: create an anonymous function


	// --------------------------------
	
	
	return window[callback_name];
}


  
// This is the callback function that manipulates the response
function func_callback(response) {
	var meta = response.meta;
	var data = response.data;
	console.log('meta: ', meta);
	console.log('data: ', data);
	return data;
}


// Way 0: using a global window
document.getElementById('script_CORS_GET').onclick = async function() {
	
	await new Promise((resolve, reject) => createScript_getResult())
	
		.then(function(data) {
			console.log("data: ", data);

			// document.getElementsByTagName('body')[0].removeChild(scriptElement);
			document.body.removeChild(scriptElement);
		});
};

// Way 2: use an eventListener to load the src
scriptElement.addEventListener('load', (event) => {
	resolve({ status: true });
	console.log('Inside eventlistener'); 
	console.log('event: ', event); 
	var data = event.target; 
	console.log('data: ', data); 
})
	
// -----------------------------------------------


// Way 1: using an eventListener
document.getElementById('script_CORS_GET1').onclick = async function() {
	await script_method(url, func_callback)
		.then(function(data) {
			console.log("data: ", data);

			// document.getElementsByTagName('body')[0].removeChild(scriptElement);
			document.body.removeChild(scriptElement);
		});
};
	

// -----------------------------------------------

async function fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type) {

	// url: url address
	// method: 'GET', 'POST'
	// data: required data format for url address
	// w_or_wo_proxyhandler: w_proxyhandler, wo_proxyhandler
	// return_type: json, blob, blob_file_pdf, arrayBuffer, text

	// --------------------------------

	// Determine request method
	var headers = {
		"Content-Type": "application/json",
		"Referer": url,
		"Origin": "https://codesolutions2.github.io",
		"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		"Access-Control-Allow-Origin": "*",
		//'Access-Control-Allow-Credentials': false, 
		//"Access-Control-Request-Method": method,
		//"Access-Control-Request-Headers": 'content-type,x-pingother',
		//'Cache-Control': 'max-age=0',
	};
	
	var options = { 
		method : method,
		mode: 'cors',
		headers: new Headers(headers),
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		redirect: "follow"
	};

	if (method == 'POST') {
		options.body = JSON.stringify(data);
	}

	// --------------------------------

	// Determine the type of output to return 
	
	if (return_type == 'json') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.json())
				.then(async function(data) { console.log('data: ', data); return data; })
				.catch(error => console.error("error: ", error));
		} else { 
			return await fetch(url, options)
				.then(response => response.json())
				.then(async function(data) { console.log('data: ', data); return data; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { console.log('blob_object: ', blob_object); return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { console.log('blob_object: ', blob_object); return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob_file_pdf') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { 
					console.log('blob_object: ', blob_object);
					return new File ([blob_object], "file_download", {type: "application/pdf"});
				})
				.then(async function(file_blob_object) {
					console.log('file_blob_object: ', file_blob_object);
					let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
					console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
					await show_pdf_on_page(github_url_of_externally_downloaded_data);

					// a file was loaded before, so remove the blob URL from memory to use resources effectively
					// URL.revokeObjectURL(github_url_of_externally_downloaded_data);
					await setTimeout(function() { URL.revokeObjectURL(github_url_of_externally_downloaded_data); }, 200);
					
					return "File blob loaded with success";
				})
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { 
					console.log('blob_object: ', blob_object);
					return new File ([blob_object], "file_download", {type: "application/pdf"});
				})
				.then(async function(file_blob_object) {
					console.log('file_blob_object: ', file_blob_object);
					let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
					console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
					await show_pdf_on_page(github_url_of_externally_downloaded_data);

					// a file was loaded before, so remove the blob URL from memory to use resources effectively
					// URL.revokeObjectURL(github_url_of_externally_downloaded_data);
					await setTimeout(function() { URL.revokeObjectURL(github_url_of_externally_downloaded_data); }, 200);
					
					return "File blob loaded with success";
				})
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'arrayBuffer') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { console.log("arraybuffer:", arraybuffer); return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { console.log("arraybuffer:", arraybuffer); return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'text') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			const proxy3 = await define_proxy_handler();
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { console.log('str_data: ', str_data); return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { console.log('str_data: ', str_data); return str_data; })
				.catch(error => console.error("error: ", error));
		}
	}

	// --------------------------------
}


async function define_proxy_handler() {
	// Parameters to influence Response Header
	// The `handler` object defines a `apply` method that intercepts the `fetch` function calls and adds the "Access-Control-Allow-Origin" header with a value of "*" to the request options. The `new Proxy(fetch, handler)` creates a proxied version of the `fetch` function that applies the defined handler.
	// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers
	const handler = {
		apply: function(target, thisArg, args) {
			// One needs to re-define the input arguments of the handler because a constant variable is used as a function (ie: await proxy3(url, options))
			const [url, options] = args;
			if (options && options.headers) {
				options.headers['Access-Control-Allow-Origin'] = '*';
				options.headers['Access-Control-Allow-Credentials'] = false;
				options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE';
				// options.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept';
				options.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
				options.headers['Access-Control-Max-Age'] = 0;
			} else {
				args[1] = {
					headers: { 
						'Access-Control-Allow-Origin': '*',
						'Access-Control-Allow-Credentials': false,
						'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
						'Access-Control-Allow-Headers': 'Content-Type, Authorization',
						'Access-Control-Max-Age': 0
					}
				};
			}
			// console.log('args: ', args);
			return Reflect.apply(target, thisArg, args);
		}
	};

	// Proxy sturcture works! 
	// Calls the function WITHOUT input variables to assign a proxy definition to a constant variable. 
	// The constant variable is called as a function, where it resolves promises. 
	// Call the constant variable proxy3 as a function to resolve the promise correctly
	return await new Proxy(fetch, handler);
}

// -----------------------------------------------
	
async function jQuery_CORS(url, method, data, return_type) {

	// https://api.jquery.com/jQuery.ajax/
	
	// url: url address
	// method: 'GET', 'POST', 'PUT'
	// data: required data format for url address
	// return_type: json, blob, blob_file_pdf, arrayBuffer, text

	var headers = {
		"Accept": "application/json",
		"Referer": url,
		"Origin": "https://codesolutions2.github.io",
		"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		"Access-Control-Allow-Origin": "*",
		//'Access-Control-Allow-Credentials': false, 
		//"Access-Control-Request-Method": method,
		//"Access-Control-Request-Headers": 'content-type,x-pingother',
		//'Cache-Control': 'max-age=0',
	};
	
	var settings = {
		// url: url,
		type : method,
		dataType: 'json', // data type response format: 'xml', html, script, json, jsonp, text, binary
		async: true,
		crossDomain: true,
		beforeSend: function(xhr) {xhr.withCredentials = true;},
		// headers: new Headers(headers),
		success: function(response) { console.log('Success'); },
		error: function(xhr, status, error) { console.log('Error:', error); }
	};

	// --------------------------------
	
	if (method == 'POST') {
		settings.body = JSON.stringify(data);
	}

	// --------------------------------

	// Determine the type of output to return 
	
	if (return_type == 'json') {
		// settings.xhrFields.responseType = 'json';
		// OR
		settings.xhrFields = {responseType: 'json'};

		return $.ajax(url, [,settings])
			.done(function(response) { console.log('response: ', response); return response; });
		
	} else if (return_type == 'blob') {
		// settings.xhrFields.responseType = 'blob';
		// OR
		settings.xhrFields = {responseType: 'blob'};
		settings.dataType = 'binary'; // change from json to [binary or text]

		var text_pdf = await $.ajax(url, [,settings]).done(function(response) { console.log('response: ', response); return response; });

		text_pdf.split()
										       
		var blob_object = new Blob([text_pdf], {type:"application/pdf"});
		// var blob_object = new Blob([text_pdf], { type: 'application/octet-stream' });
		console.log('blob_object: ', blob_object);
		return blob_object;
		
	} else if (return_type == 'blob_file_pdf') {
		settings.xhrFields = {responseType: 'blob'};
		settings.dataType = 'binary'; // change from json to [binary or text]

		var jquery_blob = await $.ajax(url, [,settings]).done(function(response) { console.log('response: ', response); return response; });

		// Convert the jquery_blob to a string
		var text_pdf = jquery_blob.toString();
		console.log('text_pdf: ', text_pdf);
		
		var blob_object = new Blob([text_pdf], {type:"application/pdf"});
		// var blob_object = new Blob([text_pdf], { type: 'application/octet-stream' });
		console.log('blob_object: ', blob_object);
		
		// var file_blob_object = new File ([blob_object], "file_download", {type: "application/pdf"});
		// console.log('file_blob_object: ', file_blob_object);
		// let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
		let github_url_of_externally_downloaded_data = URL.createObjectURL(blob_object);
		console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
		
		await show_pdf_on_page(github_url_of_externally_downloaded_data);
	
		// a file was loaded before, so remove the blob URL from memory to use resources effectively
		await setTimeout(function() { URL.revokeObjectURL(github_url_of_externally_downloaded_data); }, 200);
		
		return "File blob loaded with success";
		
	} else if (return_type == 'arrayBuffer') {
		// settings.xhrFields.responseType = 'arrayBuffer';
		// OR
		settings.xhrFields = {responseType: 'arrayBuffer'};
		settings.dataType = 'binary'; // change from json to [binary or text]

		return $.ajax(url, [,settings])
			.done(function(response) { console.log('response: ', response); return response; });
		
	} else if (return_type == 'text') {
		// settings.xhrFields.responseType = 'text';
		// OR
		settings.xhrFields = {responseType: 'text'};
		settings.dataType = 'text';

		return $.ajax(url, [,settings])
			.done(function(response) { console.log('response: ', response); return response; });
	}

	// --------------------------------
	
  	// return $.ajax(settings).done(function(response) { console.log('response: ', response); return response; });
	
}

// -----------------------------------------------

async function show_pdf_on_page(file_download_url_name) {

 	var objectElement = document.createElement('object');
  	objectElement.setAttribute("id", "pdf_object_element");
  	objectElement.setAttribute("type", "application/pdf");
  	objectElement.setAttribute("width", 800);
  	objectElement.setAttribute("height", 1200);
  	objectElement.setAttribute("data", file_download_url_name);
  	document.getElementsByTagName('body')[0].appendChild(objectElement);
}

// -----------------------------------------------

async function automatically_download(file_download_url_name) {

 	var link = document.createElement('a');
 	link.href = file_download_url_name;  // link.href = canvas.toDataURL("image/png");
 	link.download = file_download_url_name.split('/').pop();
 	link.click();
}

// -----------------------------------------------
	
</script>

  
</body>
</html>
