<!DOCTYPE html>
<html>
<head></head>
    

<body>

<button id="way0" onclick="way0()" style="display:block;" class="UsebuttonClass">way0</button>
<button id="way1" onclick="way1()" style="display:block;" class="UsebuttonClass">way1</button>
<button id="way2" onclick="way2()" style="display:block;" class="UsebuttonClass">way2</button>
<button id="way3" onclick="way3()" style="display:block;" class="UsebuttonClass">way3</button>

<script>

// ----------------------------------------------------

// Force the page to refresh the cached webpage
window.addEventListener('beforeunload', function() {
 	window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});
	
// ----------------------------------------------------

var urls2try = ['https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf', 'https://s3-us-west-2.amazonaws.com/openai-assets/research-covers/language-unsupervised/language_understanding_paper.pdf', 'https://storage.googleapis.com/on-the-way2selfrespect/yellow.png'];

// ----------------------------------------------------

// How to make a webpage wait for a result 
// Use a while loop instead of a for loop, a while loop will run the processes inside the loop in sequential order whereas a the processes inside the for loop may not be run in sequential order (asynchronously). 

// How to make a while loop stop responsively
// When running repetitive processes in a while loop, like querying a REST API endpoint followed by a pause several times, it is important to make the loop stop after the REST API endpoint returns an OK (200 or 201) status to prevent "spamming" an endpoint. 


async function way0() {
	
	// Way 0: make the loop depend on a flag in try catch
	console.log('Way 0b: make the loop depend on a flag in try catch');
	
	// if it has no error, it should stop immediately, so it should stop at i = 1
	var i = 0;
	var flag = "run";
	while (flag == "run" && i < urls2try.length) {
		try {
			console.log('url to try to fetch: ', urls2try.at(i));
			var blob_object = await fetch_CORS(urls2try.at(i));
			// if there is an error, it run everything in the try
		} catch (error) {
			console.log('error: ', error);
		}
		
		if (blob_object != undefined) {
			flag = "stop";
		}
		
		if (flag != "stop") {
			i += 1;
		}
		console.log('blob_object: ', blob_object);
		console.log('flag: ', flag);
		console.log('i: ', i);
	}

}
  
// ----------------------------------------------------
  
async function way1() {
	
	// Way 1: make the loop depend on the value of a variable
	
	var blob_object = {};

	console.log('blob_object.length: ', blob_object.length);
	
	var i = 0;
	while (blob_object.length == 0 && i < urls2try.length) {
		try {
			console.log('url to try to fetch: ', urls2try.at(i));
			blob_object = await fetch_CORS(urls2try.at(i));
			i += 1;
		} catch (error) {
			console.log('error: ', error);
		}
		console.log('blob_object: ', blob_object);
		console.log('i: ', i);
	}

}

// ----------------------------------------------------

// This method allows for the loop to stop quickly, however it may run additional processes like a REST API call

// Way 2: make the loop depend on the existence of variables
async function way2() {
	
	var blob_object = {};
	var i = 0;

	// blob_object = undefined means that blob_object = null
	
	while (blob_object != null && i < urls2try.length) {
		try {
			console.log('url to try to fetch: ', urls2try.at(i));
			blob_object = await fetch_CORS(urls2try.at(i));
			// if there is a fetch error blob_object = undefined
			
			i += 1;
		} catch (error) {
			console.log('error: ', error);
		}
		console.log('blob_object: ', blob_object);
		
		if (blob_object == undefined) { blob_object = {}; } 
		console.log('blob_object: ', blob_object);
		
		if (blob_object != {}) {
			var out = blob_object;
			delete blob_object;
		}
		
		console.log('i: ', i);
	}

}

// I found that removing the variable from memory makes the loop stop quickest, without additional unwanted processes. 

// ----------------------------------------------------
  
// Way 3: make the loop depend on the value of eventListeners (called a Signal)

function createSignal(initialValue) {
  let value = initialValue;
  const listeners = [];

  function setValue(newValue) {
    value = newValue;
    listeners.forEach(listener => listener(value));
  }

  function getValue() {
    return value;
  }

	
  function subscribe(listener) {
    listeners.push(listener);
    return () => {
      const index = listeners.indexOf(listener);
      if (index !== -1) {
        listeners.splice(index, 1);
      }
    };
  }

  return {
    setValue,
    getValue,
    subscribe,
  };
}
  
async function way3() {

	const signal = createSignal({});
	console.log('signal.getValue().length: ', signal.getValue().length);
	
	var i = 0;
	while (signal.getValue().length == 0 && i < urls2try.length) {
		try {
			console.log('url to try to fetch: ', urls2try.at(i));
			signal.setValue(await fetch_CORS(urls2try.at(i)));
			i += 1;
		} catch (error) {
			console.log('error: ', error);
		}
		console.log('signal.getValue(): ', signal.getValue());
		console.log('i: ', i);
	}

}

// -------------------------------------------------

async function fetch_CORS(url) {

	// Determine request method
	var headers_final = {
		"Content-Type": "application/json",
		"Referer": url,
		"Origin": "https://codesolutions2.github.io",
		"Connection": "keep-alive",
		//"Sec-Fetch-Dest": "empty",
		//"Sec-Fetch-Mode": "cors", 
		//"Sec-Fetch-Site": "cross-site",
		//"Sec-Fetch-User": "?1",
		"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
		"Access-Control-Allow-Origin": "*",
		//'Access-Control-Allow-Credentials': false, 
		//"Access-Control-Request-Method": method,
		//"Access-Control-Request-Headers": 'content-type,x-pingother',
		//'Cache-Control': 'max-age=0',
	};

	// Need to check if headers are in headers_final
	// To do - loop over headers and append to headers_final
	
	var options = { 
		method : 'GET',
		mode: 'cors',
		headers: new Headers(headers_final),
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		redirect: "follow"
	};

  return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { return blob_object; })
				.catch(error => console.error("error: ", error));

}
	
</script>
</body>
</html>
