<!DOCTYPE html>
<html>
<head></head>
<body>

<input id="url" type="text" value="" placeholder="url" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="lat" type="text" value="" placeholder="lat" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="lon" type="text" value="" placeholder="lon" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">

<button id="run_script" onclick="run_script()">run_script</button>
<button id="regular_fetch" onclick="regular_fetch()">regular_fetch</button>
<button id="regular_fetch_blob" onclick="regular_fetch_blob()">regular_fetch_blob</button>
	
<button id="run_selection_w_JSONP" onclick="run_selection_w_JSONP()">run_selection_w_JSONP</button>
	
<button id="run_form_GET_request" onclick="run_form_GET_request()">run_form_GET_request</button>

<button id="run_selection_w_CORS" onclick="run_selection_w_CORS()">run_selection_w_CORS</button>
<button id="get_forecast_temperature_data" onclick="get_forecast_temperature_data()">get_forecast_temperature_data</button>
	
	
<!-- <script src='https://code.jquery.com/jquery-3.6.3.min.js'></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script>
	
// -----------------------------------------------
	
window.addEventListener('beforeunload', function() {
    window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});

// -----------------------------------------------

// https://nominatim.openstreetmap.org/search?q=Lyon&format=json
// https://raw.githubusercontent.com/CodeSolutions2/pdf_to_text_webapp/main/document_imagepdf.pdf
var url = document.getElementById('url').value;
console.log('url: ', url); 
	
// -----------------------------------------------


// [Step 0] create the script element
const scriptElement = document.createElement('script');
scriptElement.type="application/json"; // "text/javascript";
scriptElement.crossorigin="*";
scriptElement.redirect="follow";
scriptElement.mode='cors';

var headers = {
	"Content-Type": "application/json",
	"Connection": "keep-alive",
	"Access-Control-Allow-Origin": "*",
};
scriptElement.headers = new Headers(headers);
console.log('[Step 0] create the script element');

	
var response;  // response is the output of running scriptElement.src


// Way 2: use an eventListener to load the src
scriptElement.addEventListener('load', (event) => {
	console.log('Inside eventlistener'); 
	console.log('event: ', event); 
	var data = event.target; 
	console.log('data: ', data); 
})
	
// This is like a template for how to use the callback with the called function
async function script_method(url, callback) {
	
	// [Step 1] Run/call the script with a callback
	console.log('[Step 1] Run/call the script with a callback');
	// This does not run/call the callback, it just assigns the callback to run the function func_callback
	// The ? starts a query, and should only be used once; there is already a ? in the url so we add callback on using &
	// The & separates value-pairs
	scriptElement.src = `${url}&callback=${callback}`;
	
	// The robot says that the assignment of scriptElement.src = `${url}&callback=callback`; causes the callback to run.

	// Where is the output of the ran command 'scriptElement.src'?

	// after the assignment of scriptElement.src = `${url}&callback=callback` such that the callback runs, how does 


	
	// [Step 2] Get the output from running scriptElement.src
	console.log('[Step 2] Get the output from running scriptElement.src')
	
	// Way 0: Basic method to call a callback
	// Problems:
	// 0) where does response come from? response is the output of running scriptElement.src.
	// 1) this has nothing to do with the callback that is defined in scriptElement.src? Yes, it does because running scriptElement.src caused the callback to return the output
	
	var data_out = await new Promise(resolve => { var data = resolve(callback(response)); return data; });
	console.log('data_out: ', data_out); 

	// Way 0b: Add a pause before resolving the callback
	// Problems:
	// 0) here does data come from?
	// 1) this has nothing to do with the callback that is defined in scriptElement.src
	// var data_out = new Promise(resolve => { setTimeout(resolve, 2000); resolve(callback(data)); });
	// console.log('data_out: ', data_out); 
	
	// Way 1: create a proxy, handler
	// Problems:
	// 0) where does response come from? response is the output of running scriptElement.src.
	var callback_name = callback.name;
	window[callback_name] = function(response) { callback.call((window), response); }
	console.log('window[callback_name]: ', window[callback_name]);
	
	
	
	
	// Way 3: create an anonymous function
  

	// Looks like one needs to append the script to the document to make it run
	// document.getElementsByTagName('body')[0].appendChild(scriptElement);
	// return data_out;
}


  
// This is the callback function that manipulates the response
function func_callback(response) {
	var meta = response.meta;
	var data = response.data;
	console.log(meta);
	console.log(data);

	// Looks like one needs to append the script to the document to make it run
	// document.getElementsByTagName('body')[0].appendChild(scriptElement);
  
  return data;
}


  

document.getElementById('run_script').onclick = async function() {
	await script_method(url, func_callback)
		// .then(function(data) {
			// console.log("data: ", data);

			// Looks like one needs to remove the script from the document to make it stop
			// document.getElementsByTagName('body')[0].removeChild(scriptElement);
		// });
};

// RESULT: no response
	
// -----------------------------------------------

async function regular_fetch() {

	var headers = {
		"Content-Type": "application/json",
		"Connection": "keep-alive",
		"Access-Control-Allow-Origin": "*",
	};
	var options = {
		method : 'GET',
		mode: 'cors',
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		headers: new Headers(headers),
		redirect: "follow"
	};
	
	await fetch(url, options)
		.then(response => response.json())
		.then(async function(data) { console.log('data: ', data); })
		.catch(error => console.error("error: ", error));
}
	
// RESULT: data:  Array []

// -----------------------------------------------

async function regular_fetch_blob() {

	var headers = {
		"Content-Type": "application/json",
		"Connection": "keep-alive",
		"Access-Control-Allow-Origin": "*",
	};
	var options = {
		method : 'GET',
		mode: 'cors',
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		headers: new Headers(headers),
		redirect: "follow"
	};
	
	await fetch(url, options)
		.then(response => response.blob())
		.then(async function(blob_object) { 
			console.log('blob_object: ', blob_object);
			// return URL.createObjectURL(blob_object); 
		})
		.catch(error => console.error(error));
}
	
// RESULT: data:  Array []

// -----------------------------------------------
	
function run_selection_w_JSONP() {
	
	var settings = {
		type: 'GET',
		url: url,
		dataType: 'jsonp',
		jsonpCallback: 'myCallBackMethod',
		async: false, // this is by default false, so not need to mention
		crossDomain: true // tell the browser to allow cross domain calls.
		// success: successResopnse, jsonpCallback will call the successCallback
		// error: failureFunction jsonp does not support errorCallback. So cannot use this 
	};

	// [Step 0] Declare a constant variable proxy as a function
	const proxy = function(response) { 
		var meta = response.meta;
		var data = response.data;
		console.log("meta: ", meta);
		console.log("data: ", data);
		return data;
	}

	// [Step 1] Assign an existing global variable named myCallBackMethod to the return of proxy function
	// Then call the constant variable proxy as a function
	window.myCallBackMethod = function(data) { return proxy(data); }

	// [Step 2] Call the fetch method from jQuery
	// They say you only need to do the callback and not a promise
	$.ajax(settings)
		.then(function(response) {
			console.log("returned GET data: ", response);
		});

	// So when ajax returns it will run the callback function called proxy. proxy basically reorganizes the data received from the server, the callback function proxy does not help one to gain access to the data it only reorganizes the data.  If one wants to gain access to the data directly, a callback is not needed.
	
	// So then does ajax return the result of myCallBackMethod

}

// RESULT: The script from “https://nominatim.openstreetmap.org/search?q=&format=json&callback=myCallBackMethod&_=1720795397518” was loaded even though its MIME type (“application/json”) is not a valid JavaScript MIME type.
// A resource is blocked by OpaqueResponseBlocking, please check browser console for details.

// -----------------------------------------------

async function run_form_GET_request() {
	
  // Create <form> element to submit parameters to endpoint
  var form = document.createElement('form');
	
  form.setAttribute('method', 'GET'); 

  // Step 0: The browser navigates to the URL given in the action attribute : the user is taken away from the current page and redirected to a new page.
  // The action attribute is used to indicate where the form’s data is sent to when it is submitted.
  form.setAttribute('action', url);


  // The form submission result will open in a new tab or window, depending on the user's browser settings.
  // form.setAttribute('target', "_blank");
	
  form.setAttribute('headers', {"Content-Type": "application/json", "Access-Control-Allow-Origin": "*"});
  
  // Just use arrays: each column is a form variable
  let type_parameters = ['text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'submit'];
  var name_parameters = ['place_id', 'licence', 'osm_type', 'osm_id', 'lat', 'lon', 'class', 'type', 'place_rank', 'importance', 'addresstype', 'name', 'display_name', 'boundingbox', 'submit'] 
  var value_parameters = [0, "", "", 0, "", "", "", "", 0, 0, "", "", "", ["", "", "", ""], 'submit'];

	
	
  type_parameters.forEach(async function(type_val, index) {
	  let type = type_val;
	  let name = name_parameters[index];
	  let value = value_parameters[index];
	  
    var input = document.createElement('input');
    input.innerHTML = '<input style="display:none;" type=' +type+ ' name=' +name+ 'value=' +value+ '>';
          
     form.appendChild(input);
    });

  // Add form to page and submit it to open the endpoint.
  document.body.appendChild(form);
	
  form.submit();
}

// Add an eventlistener to a button, when the button is clicked, do not redirect AND output the form results
// Do not redirect page to the page that we want to perform GET,POST requests with
document.getElementById("run_form_GET_request").addEventListener("click", (event) => {
	event.preventDefault();
	console.log("Form submitted with click");
});

document.getElementById("run_form_GET_request").addEventListener("submit", (event) => {
	event.preventDefault();
	console.log("Form submitted with submit");
});

	
// https://nominatim.openstreetmap.org/ui/search.html?place_idvalue%3D0=&licencevalue%3D=&osm_typevalue%3D=&osm_idvalue%3D0=&latvalue%3D=&lonvalue%3D=&classvalue%3D=&typevalue%3D=&place_rankvalue%3D0=&importancevalue%3D0=&addresstypevalue%3D=&namevalue%3D=&display_namevalue%3D=&boundingboxvalue%3D%2C%2C%2C=

// -----------------------------------------------

async function run_selection_w_CORS() {

  var settings = {
		url: url,
		type : 'GET',
		dataType: 'json',
		async: true,
		crossDomain: true,
		success: function(response) { console.log(response); },
		error: function(xhr, status, error) { console.log('Error:', error); }
	};

  $.ajax(settings).done(function(response) { console.log('response: ', response); })
}

// RESULT: data:  Array []

// -----------------------------------------------

async function get_forecast_temperature_data() {

	var location_latitude = document.getElementById('lat').innerHTML;
	var location_longitude = document.getElementById('lon').innerHTML;

	
    // https://open-meteo.com/en/docs

  var url = 'https://open-meteo.com/v1/forecast';
	  
		var headers = {
			"Content-Type": "application/json",
			"Connection": "keep-alive",
			"Access-Control-Allow-Origin": "*",
		};
	
		var data = {"latitude": Number(location_latitude),
			    "longitude": Number(location_longitude), 
			    "forecast_days": 1, 
			    "forecast_hours": 5
		};
		
		// --------------------
		
		var options = {
			method : 'POST', 
			body : JSON.stringify(data),
			mode: 'cors',
			cache: "no-cache",
			// crossorigin: 'anonymous',
			crossorigin: '*',
			headers: new Headers(headers),
			redirect: "follow"
		};
		
		// ------------------------------------------
		
		await fetch(url, options)
			.then(res => res.json())
			.then(res => { 
				let output = JSON.parse(JSON.stringify(res));
				console.log('output: ', output);
			})
			.catch(error => { console.error("error: ", error) });

}

// Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://open-meteo.com/v1/forecast. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing). Status code: 404.

// Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://open-meteo.com/v1/forecast. (Reason: CORS request did not succeed). Status code: (null).

// error:  TypeError: NetworkError when attempting to fetch resource. index2.html:224:30
	
// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------
	
</script>

  
</body>
</html>
