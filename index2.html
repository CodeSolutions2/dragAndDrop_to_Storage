<!DOCTYPE html>
<html>
<head></head>
<body>

<input id="location_name" type="text" value="" placeholder="location_name" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">

<button id="run_script" onclick="run_script()">run_script</button>
<button id="regular_fetch" onclick="regular_fetch()">regular_fetch</button>
<button id="run_selection_w_JSONP" onclick="run_selection_w_JSONP()">run_selection_w_JSONP</button>
<button id="run_form_GET_request" onclick="run_form_GET_request()" style="display:block">run_form_GET_request</button>
<button id="run_selection_w_CORS" onclick="run_selection_w_CORS()">run_selection_w_CORS</button>

	
<!-- <script src='https://code.jquery.com/jquery-3.6.3.min.js'></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script>
	
// -----------------------------------------------
	
window.addEventListener('beforeunload', function() {
    window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});

// -----------------------------------------------

var url = `https://nominatim.openstreetmap.org/search?q=${document.getElementById('location_name').innerHTML}&format=json`;

// -----------------------------------------------

const scriptElement = document.createElement('script');
var data = [];

// This is like a template for how to use the callback with the called function
async function script_method(url, callback) {
	scriptElement.type="text/javascript";
	scriptElement.crossorigin="anonymous";
	scriptElement.redirect="follow";
	scriptElement.mode='cors';
	var headers = {
		"Content-Type": "application/json",
		"Connection": "keep-alive",
		"Access-Control-Allow-Origin": "*",
	};
	scriptElement.headers=new Headers(headers);
	scriptElement.src = `${url}&callback=callback`;

	// Looks like one needs to append the script to the document to make it run
	document.getElementsByTagName('body')[0].appendChild(scriptElement);
	return data;
}

// This is the callback function that manipulates the response
function func_callback(response) {
	var meta = response.meta;
	data = response.data;
	console.log(meta);
	console.log(data);

	// Looks like one needs to append the script to the document to make it run
	// document.getElementsByTagName('body')[0].appendChild(scriptElement);
	return data;
}

document.getElementById('run_script').onclick = async function() {
	await script_method(url, func_callback)
		.then(function(data) {
			console.log("data: ", data);

			// Looks like one needs to remove the script from the document to make it stop
			document.getElementsByTagName('body')[0].removeChild(scriptElement);
		});
};

// RESULT: no response
	
// -----------------------------------------------

async function regular_fetch() {

	var headers = {
		"Content-Type": "application/json",
		"Connection": "keep-alive",
		"Access-Control-Allow-Origin": "*",
	};
	var options = {
		method : 'GET',
		mode: 'cors',
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		headers: new Headers(headers),
		redirect: "follow"
	};
	
	await fetch(url, options)
		.then(response => response.json())
		.then(async function(data) { console.log('data: ', data); })
		.catch(error => console.error("error: ", error));
}
	
// RESULT: data:  Array []
	
// -----------------------------------------------
	
function run_selection_w_JSONP() {
	
	var settings = {
		type: 'GET',
		url: url,
		dataType: 'jsonp',
		jsonpCallback: 'myCallBackMethod',
		async: false, // this is by default false, so not need to mention
		crossDomain: true // tell the browser to allow cross domain calls.
		// success: successResopnse, jsonpCallback will call the successCallback
		// error: failureFunction jsonp does not support errorCallback. So cannot use this 
	};

	// [Step 0] Declare a constant variable proxy as a function
	const proxy = function(response) { 
		var meta = response.meta;
		var data = response.data;
		console.log("meta: ", meta);
		console.log("data: ", data);
		return data;
	}

	// [Step 1] Assign an existing global variable named myCallBackMethod to the return of proxy function
	// Then call the constant variable proxy as a function
	window.myCallBackMethod = function(data) { return proxy(data); }

	// [Step 2] Call the fetch method from jQuery
	// They say you only need to do the callback and not a promise
	$.ajax(settings)
		.then(function(response) {
			console.log("returned GET data: ", response);
		});

	// So when ajax returns it will run the callback function called proxy. proxy basically reorganizes the data received from the server, the callback function proxy does not help one to gain access to the data it only reorganizes the data.  If one wants to gain access to the data directly, a callback is not needed.
	
	// So then does ajax return the result of myCallBackMethod

}

// RESULT: The script from “https://nominatim.openstreetmap.org/search?q=&format=json&callback=myCallBackMethod&_=1720795397518” was loaded even though its MIME type (“application/json”) is not a valid JavaScript MIME type.
// A resource is blocked by OpaqueResponseBlocking, please check browser console for details.

// -----------------------------------------------

async function run_form_GET_request() {
	
  // Create <form> element to submit parameters to endpoint
  var form = document.createElement('form');
	
  form.setAttribute('method', 'GET'); 

  // Step 0: The browser navigates to the URL given in the action attribute : the user is taken away from the current page and redirected to a new page.
  // The action attribute is used to indicate where the form’s data is sent to when it is submitted.
  form.setAttribute('action', url);


  // The form submission result will open in a new tab or window, depending on the user's browser settings.
  // form.setAttribute('target', "_blank");
	
  form.setAttribute('headers', {"Content-Type": "application/json", "Access-Control-Allow-Origin": "*"});
  
  // Just use arrays: each column is a form variable
  let type_parameters = ['text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'submit'];
  var name_parameters = ['place_id', 'licence', 'osm_type', 'osm_id', 'lat', 'lon', 'class', 'type', 'place_rank', 'importance', 'addresstype', 'name', 'display_name', 'boundingbox', 'confirm_submit'] 
  var value_parameters = [0, "", "", 0, "", "", "", "", 0, 0, "", "", "", ["", "", "", ""], 'Submit'];

	
	
  type_parameters.forEach(async function(type_val, index) {
	  let type = type_val;
	  let name = name_parameters[index];
	  let value = value_parameters[index];
	  
    var input = document.createElement('input');
    input.innerHTML = '<input style="display:none;" type=' +type+ ' name=' +name+ 'value=' +value+ '>';
          
     form.appendChild(input);
    });

  // Add form to page and submit it to open the endpoint.
  document.body.appendChild(form);
	
  form.submit();
  
}

// https://nominatim.openstreetmap.org/ui/search.html?place_idvalue%3D0=&licencevalue%3D=&osm_typevalue%3D=&osm_idvalue%3D0=&latvalue%3D=&lonvalue%3D=&classvalue%3D=&typevalue%3D=&place_rankvalue%3D0=&importancevalue%3D0=&addresstypevalue%3D=&namevalue%3D=&display_namevalue%3D=&boundingboxvalue%3D%2C%2C%2C=

// -----------------------------------------------

async function run_selection_w_CORS() {

  var settings = {
		url: url,
		type : 'GET',
		dataType: 'json',
		async: true,
		crossDomain: true,
		success: function(response) { console.log(response); },
		error: function(xhr, status, error) { console.log('Error:', error); }
	};

  $.ajax(settings).done(function(response) { console.log('response: ', response); })
}

// RESULT: data:  Array []

// -----------------------------------------------

</script>

  
</body>
</html>
