<!DOCTYPE html>
<html>
<head></head>
<body>

<input id="url" type="text" value="" placeholder="url" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="method" type="text" value="" placeholder="method" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="w_or_wo_proxyhandler" type="text" value="" placeholder="w_or_wo_proxyhandler" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
<input id="return_type" type="text" value="" placeholder="return_type" rows="10" cols="100" style="display:block; text-align: left; width: 600px;">
	
<button id="script_CORS_GET" onclick="script_CORS_GET()">script_CORS_GET</button>
	
<button id="run_fetch_CORS" onclick="run_fetch_CORS()">run_fetch_CORS</button>

<button id="jQuery_w_JSONP_GET" onclick="jQuery_w_JSONP_GET()">jQuery_w_JSONP_GET</button>
	
<button id="form_w_CORS_GET" onclick="form_w_CORS_GET()">form_w_CORS_GET</button>

<button id="jQuery_w_CORS_GET" onclick="jQuery_w_CORS_GET()">jQuery_w_CORS_GET</button>
<button id="jQuery_w_CORS_blob_GET" onclick="jQuery_w_CORS_blob_GET()">jQuery_w_CORS_blob_GET</button>
<button id="jQuery_w_CORS_POST" onclick="jQuery_w_CORS_POST()">jQuery_w_CORS_POST</button>

<button id="get_forecast_temperature_data" onclick="get_forecast_temperature_data()">get_forecast_temperature_data</button>
	
	
<!-- <script src='https://code.jquery.com/jquery-3.6.3.min.js'></script> -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js" integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>


<script>
	
// -----------------------------------------------
	
window.addEventListener('beforeunload', function() {
    window.location.href = window.location.href + '?nocache=' + new Date().getTime();
});

// -----------------------------------------------

// https://nominatim.openstreetmap.org/search?q=Lyon&format=json
// https://raw.githubusercontent.com/CodeSolutions2/pdf_to_text_webapp/main/document_imagepdf.pdf
// https://www.w3.org/WAI/ER/tests/xhtml/testfiles/resources/pdf/dummy.pdf
	
// -----------------------------------------------

async function run_fetch_CORS() {

	var url = document.getElementById('url').value;  // url: url address
	var method = document.getElementById('method').value;  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var w_or_wo_proxyhandler = document.getElementById('w_or_wo_proxyhandler').value;  // w_or_wo_proxyhandler: w_proxyhandler, wo_proxyhandler
	var return_type = document.getElementById('return_type').value;  // return_type: json, blob, blob_file_pdf, arrayBuffer, text

	var data = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('data: ', data); 
}

// -----------------------------------------------

async function run_jQuery_CORS() {
	var data = await jQuery_CORS(url, return_type);
	console.log('data: ', data); 
}
	
// -----------------------------------------------

// -----------------------------------------------
	

// -----------------------------------------------
	

// -----------------------------------------------
// SUBFUNCTIONS
// -----------------------------------------------
	
// [Step 0] create the script element
const scriptElement = document.createElement('script');
scriptElement.type="application/json"; // "text/javascript";
scriptElement.crossorigin="*";
scriptElement.redirect="follow";
scriptElement.mode='cors';

var headers = {
	"Content-Type": "application/json",
	"Connection": "keep-alive",
	"Access-Control-Allow-Origin": "*",
};
scriptElement.headers = new Headers(headers);
console.log('[Step 0] create the script element');

	
var response;  // response is the output of running scriptElement.src


// Way 2: use an eventListener to load the src
scriptElement.addEventListener('load', (event) => {
	console.log('Inside eventlistener'); 
	console.log('event: ', event); 
	var data = event.target; 
	console.log('data: ', data); 
})
	
// This is like a template for how to use the callback with the called function
async function script_method(url, callback) {
	
	// [Step 1] Run/call the script with a callback
	console.log('[Step 1] Run/call the script with a callback');
	// This does not run/call the callback, it just assigns the callback to run the function func_callback
	// The ? starts a query, and should only be used once; there is already a ? in the url so we add callback on using &
	// The & separates value-pairs
	scriptElement.src = `${url}&callback=${callback}`;
	
	// The robot says that the assignment of scriptElement.src = `${url}&callback=callback`; causes the callback to run.

	// Where is the output of the ran command 'scriptElement.src'?

	// after the assignment of scriptElement.src = `${url}&callback=callback` such that the callback runs, how does 


	
	// [Step 2] Get the output from running scriptElement.src
	console.log('[Step 2] Get the output from running scriptElement.src')

	// --------------------------------
	
	// Way 0: Basic method to call a callback
	// Problems:
	// 0) where does response come from? response is the output of running scriptElement.src.
	// 1) this has nothing to do with the callback that is defined in scriptElement.src? Yes, it does because running scriptElement.src caused the callback to return the output
	
	// var data_out = await new Promise(resolve => { var data = resolve(callback(response)); return data; });
	// console.log('data_out: ', data_out); 
	
	// RESULT: gives an error because scriptElement.src does not return the response to the callback
	

	// Way 0b: Add a pause before resolving the callback
	// Problems:
	// 0) here does data come from?
	// 1) this has nothing to do with the callback that is defined in scriptElement.src
	// var data_out = new Promise(resolve => { setTimeout(resolve, 2000); resolve(callback(data)); });
	// console.log('data_out: ', data_out); 

	// --------------------------------
	
	// Way 1: create a proxy, handler
	// Problems:
	// 0) where does response come from? response is the output of running scriptElement.src.
	var callback_name = callback.name;
	window[callback_name] = function(response) { 
		console.log('response: ', response);
		return new Promise(resolve => { var data = resolve(callback.call((window), response)); return data; });
	}
	console.log('window[callback_name]: ', window[callback_name]);
	
	// --------------------------------
	
	// Way 3: create an anonymous function


	// --------------------------------
	
	// Looks like one needs to append the script to the document to make it run
	document.getElementsByTagName('body')[0].appendChild(scriptElement);
	return window[callback_name];
}


  
// This is the callback function that manipulates the response
function func_callback(response) {
	var meta = response.meta;
	var data = response.data;
	console.log('meta: ', meta);
	console.log('data: ', data);
	
	return data;
}


  

document.getElementById('script_CORS_GET').onclick = async function() {
	await script_method(url, func_callback)
		.then(function(data) {
			console.log("data: ", data);

			// Looks like one needs to remove the script from the document to make it stop
			document.getElementsByTagName('body')[0].removeChild(scriptElement);
		});
};

// RESULT: no response
	
// -----------------------------------------------

async function fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type) {

	// url: url address
	// method: 'GET', 'POST'
	// data: required data format for url address
	// w_or_wo_proxyhandler: w_proxyhandler, wo_proxyhandler
	// return_type: json, blob, blob_file_pdf, arrayBuffer, text

	// --------------------------------

	// Determine request method
	var options = { 
		method : method,
		mode: 'cors',
		cache: "no-cache",
		// crossorigin: 'anonymous',
		crossorigin: '*',
		redirect: "follow"
	};

	if (method == 'POST') {
		options.body = JSON.stringify(data);
	}

	// --------------------------------
	
	// Determine request settings for the request and response headers
		
	if (w_or_wo_proxyhandler == 'w_proxyhandler') {
		// Parameters to influence Response Header
		// The `handler` object defines a `apply` method that intercepts the `fetch` function calls and adds the "Access-Control-Allow-Origin" header with a value of "*" to the request options. The `new Proxy(fetch, handler)` creates a proxied version of the `fetch` function that applies the defined handler.
		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Headers
		const handler = {
			apply: function(target, thisArg, args) {
				// One needs to re-define the input arguments of the handler because a constant variable is used as a function (ie: await proxy3(url, options))
				const [url, options] = args;
				if (options && options.headers) {
					options.headers['Access-Control-Allow-Origin'] = '*';
					options.headers['Access-Control-Allow-Credentials'] = false;
					options.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE';
					// options.headers['Access-Control-Allow-Headers'] = 'Origin, X-Requested-With, Content-Type, Accept';
					options.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization';
					options.headers['Access-Control-Max-Age'] = 0;
				} else {
					args[1] = {
						headers: { 
							'Access-Control-Allow-Origin': '*',
							'Access-Control-Allow-Credentials': false,
							'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE',
							'Access-Control-Allow-Headers': 'Content-Type, Authorization',
							'Access-Control-Max-Age': 0
						}
					};
		 		}
		 		// console.log('args: ', args);
		 		return Reflect.apply(target, thisArg, args);
			}
		};

		// Proxy sturcture works! 
		// Calls the function WITHOUT input variables to assign a proxy definition to a constant variable. 
		// The constant variable is called as a function, where it resolves promises. 
		// Call the constant variable proxy3 as a function to resolve the promise correctly
		const proxy3 = new Proxy(fetch, handler);

		// --------------------------------
		
		// https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers
		// "Sec-Fetch-Mode": "cors", // Indicates the request's mode to a server: cors, navigate, no-cors, same-origin, websocket
	
		// Sec-Fetch-User:  ?0 = false, ?1 = true
		// Sec-Fetch-Dest: audio, audioworklet, document, embed, empty, font, image, manifest, object, paintworklet, report, script, serviceworker, sharedworker, style, track, video, worker, and xslt
		// "Sec-Fetch-Site": "cross-site", // cross-site, same-origin, same-site, none
		// 'Cache-Control': 'max-age=0' // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security?utm_source=mozilla&utm_medium=devtools-netmonitor&utm_campaign=default - this allows one to change the preflight request, other wise the preflight request settings are set for a year
		var headers = {
			"Content-Type": "application/json",
			"Referer": url,
			"Origin": "https://codesolutions2.github.io",
			"Connection": "keep-alive",
			//"Sec-Fetch-Dest": "empty",
			//"Sec-Fetch-Mode": "cors", 
			//"Sec-Fetch-Site": "cross-site",
			//"Sec-Fetch-User": "?1",
			"User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:120.0) Gecko/20100101 Firefox/120.0",
			"Access-Control-Allow-Origin": "*",
			//'Access-Control-Allow-Credentials': false, 
			//"Access-Control-Request-Method": method,
			//"Access-Control-Request-Headers": 'content-type,x-pingother',
			//'Cache-Control': 'max-age=0',
		};
	} else { 
		var headers = {
			"Content-Type": "application/json",
			"Connection": "keep-alive",
			"Access-Control-Allow-Origin": "*",
		};
	}

	options.headers = new Headers(headers);

	// --------------------------------

	// Determine the type of output to return 
	
	if (return_type == 'json') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			return await proxy3(url, options)
				.then(response => response.json())
				.then(async function(data) { console.log('data: ', data); return data; })
				.catch(error => console.error("error: ", error));
		} else { 
			return await fetch(url, options)
				.then(response => response.json())
				.then(async function(data) { console.log('data: ', data); return data; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { console.log('blob_object: ', blob_object); return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { console.log('blob_object: ', blob_object); return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'blob_file_pdf') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			return await proxy3(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { 
					console.log('blob_object: ', blob_object);
					return new File ([blob_object], "file_download", {type: "application/pdf"});
				})
				.then(async function(file_blob_object) {
					console.log('file_blob_object: ', file_blob_object);
					let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
					console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
					await show_pdf_on_page(github_url_of_externally_downloaded_data);
				})
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.blob())
				.then(async function(blob_object) { 
					console.log('blob_object: ', blob_object);
					return new File ([blob_object], "file_download", {type: "application/pdf"});
				})
				.then(async function(file_blob_object) {
					console.log('file_blob_object: ', file_blob_object);
					let github_url_of_externally_downloaded_data = URL.createObjectURL(file_blob_object);
					console.log('github_url_of_externally_downloaded_data: ', github_url_of_externally_downloaded_data);
					await show_pdf_on_page(github_url_of_externally_downloaded_data);
				})
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'arrayBuffer') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			return await proxy3(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { console.log("arraybuffer:", arraybuffer); return blob_object; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(response => response.arrayBuffer())
				.then(async function(arraybuffer) { console.log("arraybuffer:", arraybuffer); return blob_object; })
				.catch(error => console.error("error: ", error));
		}
		
	} else if (return_type == 'text') {
		if (w_or_wo_proxyhandler == 'w_proxyhandler') {
			return await proxy3(url, options)
				.then(res => res.text())
				.then(str_data => { console.log('str_data: ', str_data); return str_data; })
				.catch(error => console.error("error: ", error));
		} else {
			return await fetch(url, options)
				.then(res => res.text())
				.then(str_data => { console.log('str_data: ', str_data); return str_data; })
				.catch(error => console.error("error: ", error));
		}
	}

	// --------------------------------
}

// -----------------------------------------------
	
function jQuery_w_JSONP_GET(url) {
	
	var settings = {
		type: 'GET',
		url: url,
		dataType: 'jsonp',
		jsonpCallback: 'myCallBackMethod',
		async: false, // this is by default false, so not need to mention
		crossDomain: true // tell the browser to allow cross domain calls.
		// success: successResopnse, jsonpCallback will call the successCallback
		// error: failureFunction jsonp does not support errorCallback. So cannot use this 
	};

	// [Step 0] Declare a constant variable proxy as a function
	const proxy = function(response) { 
		var meta = response.meta;
		var data = response.data;
		console.log("meta: ", meta);
		console.log("data: ", data);
		return data;
	}

	// [Step 1] Assign an existing global variable named myCallBackMethod to the return of proxy function
	// Then call the constant variable proxy as a function
	window.myCallBackMethod = function(data) { return proxy(data); }

	// [Step 2] Call the fetch method from jQuery
	// They say you only need to do the callback and not a promise
	$.ajax(settings)
		.then(function(response) {
			console.log("returned GET data: ", response);
		});

	// So when ajax returns it will run the callback function called proxy. proxy basically reorganizes the data received from the server, the callback function proxy does not help one to gain access to the data it only reorganizes the data.  If one wants to gain access to the data directly, a callback is not needed.
	
	// So then does ajax return the result of myCallBackMethod

}

// RESULT: The script from “https://nominatim.openstreetmap.org/search?q=&format=json&callback=myCallBackMethod&_=1720795397518” was loaded even though its MIME type (“application/json”) is not a valid JavaScript MIME type.
// A resource is blocked by OpaqueResponseBlocking, please check browser console for details.

// -----------------------------------------------

async function form_w_CORS_GET(url) {
	
  // Create <form> element to submit parameters to endpoint
  var form = document.createElement('form');
	
  form.setAttribute('method', 'GET'); 

  // Step 0: The browser navigates to the URL given in the action attribute : the user is taken away from the current page and redirected to a new page.
  // The action attribute is used to indicate where the form’s data is sent to when it is submitted.
  form.setAttribute('action', url);


  // The form submission result will open in a new tab or window, depending on the user's browser settings.
  // form.setAttribute('target', "_blank");
	
  form.setAttribute('headers', {"Content-Type": "application/json", "Access-Control-Allow-Origin": "*"});
  
  // Just use arrays: each column is a form variable
  let type_parameters = ['text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'text', 'submit'];
  var name_parameters = ['place_id', 'licence', 'osm_type', 'osm_id', 'lat', 'lon', 'class', 'type', 'place_rank', 'importance', 'addresstype', 'name', 'display_name', 'boundingbox', 'submit'] 
  var value_parameters = [0, "", "", 0, "", "", "", "", 0, 0, "", "", "", ["", "", "", ""], 'submit'];

	
	
  type_parameters.forEach(async function(type_val, index) {
	  let type = type_val;
	  let name = name_parameters[index];
	  let value = value_parameters[index];
	  
    var input = document.createElement('input');
    input.innerHTML = '<input style="display:none;" type=' +type+ ' name=' +name+ 'value=' +value+ '>';
          
     form.appendChild(input);
    });

  // Add form to page and submit it to open the endpoint.
  document.body.appendChild(form);
	
  form.submit();
}

// Add an eventlistener to a button, when the button is clicked, do not redirect AND output the form results
// Do not redirect page to the page that we want to perform GET,POST requests with
document.getElementById("form_w_CORS_GET").addEventListener("click", (event) => {
	event.preventDefault();
	console.log("Form submitted with click");
});

document.getElementById("form_w_CORS_GET").addEventListener("submit", (event) => {
	event.preventDefault();
	console.log("Form submitted with submit");
});

	
// https://nominatim.openstreetmap.org/ui/search.html?place_idvalue%3D0=&licencevalue%3D=&osm_typevalue%3D=&osm_idvalue%3D0=&latvalue%3D=&lonvalue%3D=&classvalue%3D=&typevalue%3D=&place_rankvalue%3D0=&importancevalue%3D0=&addresstypevalue%3D=&namevalue%3D=&display_namevalue%3D=&boundingboxvalue%3D%2C%2C%2C=

// -----------------------------------------------

async function jQuery_w_CORS_GET(url) {

  var settings = {
		url: url,
		type : 'GET',
		dataType: 'json',
		async: true,
		crossDomain: true,
		success: function(response) { console.log('Success'); },
		error: function(xhr, status, error) { console.log('Error:', error); }
	};

  return $.ajax(settings).done(function(response) { console.log('response: ', response); return response; })
}

// -----------------------------------------------

async function jQuery_w_CORS_blob_GET(url) {

  var settings = {
		url: url,
		type : 'GET',
		dataType: 'json',
		xhrFields: {responseType: 'blob'},
		async: true,
		crossDomain: true,
		success: function(response) { console.log('Success'); },
		error: function(xhr, status, error) { console.log('Error:', error); }
	};

  $.ajax(settings).done(function(response) { console.log('response: ', response); })
}

// -----------------------------------------------

async function jQuery_w_CORS_POST(url, data) {

  var settings = {
		url: url,
		type : 'POST',
		dataType: 'json',
	  	body : JSON.stringify(data),
		async: true,
		crossDomain: true,
		success: function(response) { console.log('Success'); },
		error: function(xhr, status, error) { console.log('Error:', error); }
	};

  return $.ajax(settings).done(function(response) { console.log('response: ', response); return response; })
}
	
// -----------------------------------------------

async function get_forecast_temperature_data(url) {
	
	// [Step 0] Get latitude and longitude
	var url = 'https://nominatim.openstreetmap.org/search?q=Lyon&format=json';
	var method = 'GET';  // method: 'GET', 'POST'
	var data = [];  // data: required data format for url address
	var w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	var return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	var out = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('out: ', out); 

	// --------------------------------

	var location_latitude = out[0].lat;
	var location_longitude = out[0].lon;
	console.log("location_latitude: ", location_latitude);
	console.log("location_longitude: ", location_longitude);

	// [Step 0] Get weather data
	// https://open-meteo.com/en/docs

	url = 'https://open-meteo.com/v1/forecast';
	method = 'POST';  // method: 'GET', 'POST'
	data = {"latitude": Number(location_latitude),
			    "longitude": Number(location_longitude), 
			    "forecast_days": 1, 
			    "forecast_hours": 5
		};  // data: required data format for url address
	w_or_wo_proxyhandler = 'w_proxyhandler';  // w_or_wo_proxyhandler: 'w_proxyhandler', 'wo_proxyhandler'
	return_type = 'json';  // return_type: 'json', 'blob', 'blob_file_pdf', 'arrayBuffer', 'text'
	out = await fetch_CORS(url, method, data, w_or_wo_proxyhandler, return_type);
	console.log('out: ', out);
	  
}

// Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://open-meteo.com/v1/forecast. (Reason: CORS header ‘Access-Control-Allow-Origin’ missing). Status code: 404.

// Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at https://open-meteo.com/v1/forecast. (Reason: CORS request did not succeed). Status code: (null).

// error:  TypeError: NetworkError when attempting to fetch resource. index2.html:224:30
	
// -----------------------------------------------


async function show_pdf_on_page(file_download_url_name) {

 	var objectElement = document.createElement('object');
  	objectElement.setAttribute("id", "pdf_object_element");
  	objectElement.setAttribute("type", "application/pdf");
  	objectElement.setAttribute("width", 800);
  	objectElement.setAttribute("height", 1200);
  	objectElement.setAttribute("data", file_download_url_name);
  	document.getElementById('pdf_viewer_output').appendChild(objectElement);
}

// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------


// -----------------------------------------------
	
</script>

  
</body>
</html>
