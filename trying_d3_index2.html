<!DOCTYPE html>
<html>
<head></head>
<body>


<button id="use_DOM_w_d3" onclick="use_DOM_w_d3()" style="display:block;">use_DOM_w_d3</button>

<button id="plot_dataArray_values_to_text" onclick="plot_dataArray_values_to_text()" style="display:block;">plot_dataArray_values_to_text</button>


<!-- Drop down menu: put in body -->
<label for="select_dropdown_option_label">Select a drop down option to plot_bar_graph:</label>
<select name="dropdown_options" id="dropdown_options" style="display:block">
  <option value="---">Select an option</option>
  <option value="drop_down_option0">drop_down_option0</option>
  <option value="drop_down_option1">drop_down_option1</option>
  <option value="drop_down_option2">drop_down_option2</option>
</select>
<button id="plot_bar_graph" onclick="plot_bar_graph()" style="display:none;">plot_bar_graph</button>
	
<button id="plot_line_graph_dataArray" onclick="plot_line_graph_dataArray()" style="display:block;">plot_line_graph_dataArray</button>
	
<button id="plot_line_graph_dataObject" onclick="plot_line_graph_dataObject()" style="display:block;">plot_line_graph_dataObject</button>
	
<button id="plot_timeseries_data" onclick="plot_timeseries_data()" style="display:block;">plot_timeseries_data</button>


<div id="data_display" style="display:block; text-align: left; width: 600px;"></div>
	

<script src='https://d3js.org/d3.v7.min.js'></script>


<script>

// -----------------------------------------------

// Ensure that all UI element reset
window.addEventListener('beforeunload', function() {
	window.location.href = window.location.href + '?nocache=' + new Date().getTime();
	
	// Reset dropdowns
	document.getElementById("dropdown_options").selectedIndex = 0;
});

// -----------------------------------------------
	
// Put in <script>
async function processEvent_dropdown_options(event) {

	const element = document.getElementById("dropdown_options");
	console.log('element.selectedIndex: ', element.selectedIndex);
	
	if (document.getElementById("dropdown_options").selectedIndex == 0) {
		document.getElementById("plot_bar_graph").style.display = 'none';
	} else {
		// Make button appear
		document.getElementById("plot_bar_graph").style.display = 'block';
	}
}

document.getElementById("dropdown_options").addEventListener("change", processEvent_dropdown_options, false);
	
// -----------------------------------------------

async function use_DOM_w_d3() {

	d3.select();
	d3.selectAll();

	// h1 has to already exist
	var h1Element = document.createElement('h1');
	document.body.appendChild(h1Element);
	d3.select('h1').style('color', 'red').attr('class', 'heading').text('Updated h1 tag');

	// If h1 does not exist
	// d3.select('body').append('h1').style('color', 'red').attr('class', 'heading').text('Updated h1 tag');

	// If a paragraph Element does not exist
	d3.select('body').append('p').text('First Paragraph');  // prints to body -> paragraph
	d3.select('body').append('p').text('Second Paragraph');	// prints to body -> paragraph
	d3.select('body').append('p').text('Third Paragraph');	// prints to body -> paragraph
	
	d3.selectAll('p').style('color', 'blue');

}

// -----------------------------------------------

async function plot_dataArray_values_to_text() {

	const dataArray = [30, 50, 80, 120, 200];

	var example = 1;

	if (example == 0) {

		// Append a <paragraph tag> to each value in the dataArray, then append text value to each value in the dataArray
		
		d3.select('body')
		    .selectAll('p') // select all the paragraph tags in the body DOM element
			// If there are no paragraph tags assigned on the DOM, it returns an empty selection.
		    .data(dataArray) // put data into "the waiting state" 
		    .enter() // take one data item one-by-one to perform operations on them
		    .append('p') // appends <paragraph> tag to each data value
		    .text('text appended to paragraph');

		// Result: prints 5 times to the DOM body -> paragraph

		// text appended to paragraph

		// text appended to paragraph

		// text appended to paragraph

		// text appended to paragraph

		// text appended to paragraph
		
	} else if (example == 1) {

		d3.select('body')
		    .selectAll('p') // select all the paragraph tags in the body DOM element
			// If there are no paragraph tags assigned on the DOM, it returns an empty selection.
		    .data(dataArray) // put data into "the waiting state" 
		    .enter() // take one data item one-by-one to perform operations on them
		    .append('p') // appends paragraph for each data element
		    .text(function(d) { return d; }); // print the value of dataArray to each paragraph item

	} 
	
}

// -----------------------------------------------

async function plot_bar_graph() {
	
	const dataArray = [30, 50, 80, 120, 200];
	

	const w = 400;
	const h = 400;

	// ---------------------------------------------------

	// [Step 0] Assign bar width of each bar [*** choose it with respect to dataArray values ***]

	// [SubStep a] Assign the width of the bar based on the height of the data
	
	// GOAL: Select a percentage of something (ie: bar width) that one can visualize with respect to something known (ie: max data value)
	const bar_width_percentage_wrt_max_dataValue = 0.05; // *** USER INPUT ONLY : bar_width is XXX percent of max dataArray value ***
	
	const arr_sort = dataArray.sort();
	const [min_val, max_val] = [arr_sort.at(0), arr_sort.at(arr_sort.length-1)];
	
	const bar_width_wo_padding = Math.floor(bar_width_percentage_wrt_max_dataValue*max_val);
	console.log("bar_width_wo_padding: ", bar_width_wo_padding);
	

	// [SubStep b] Assign the space between each bar based on the width (ie: bar_width padding)
	
	// GOAL: Select a percentage of something (ie: space between bars) that one can visualize with respect to something known (ie: bar_width)
	const padding_percentage_wrt_barWidth = 0.05; // *** USER INPUT ONLY : padding/space between bars is XXX percent of bar_width ***
	
	const padding = Math.floor(padding_percentage_wrt_barWidth*bar_width_wo_padding);
	console.log("padding: ", padding);

	// The part of the bar that will be filled in with color is bar_width, the padding part will have no color
	const bar_width = bar_width_wo_padding - padding;
	console.log("bar_width: ", bar_width);
	
	// ---------------------------------------------------

	// [Step 2] Assign bar_height of each bar [*** choose it with respect to dataArray values ***]
	const bar_height = dataArray;
	console.log("bar_height: ", bar_height);

	// ---------------------------------------------------
	
	// [Step 3] Assign x, the (x-location) of each bar with respect to w
	const w_divided_by_dataPoint_length = Math.floor(w/dataArray.length);
	const x = dataArray.map((val, ind) => { return ind * w_divided_by_dataPoint_length; });
	console.log("x: ", x);
	
	// ---------------------------------------------------
	
	// [Step 4] Assign y, the (y-location) of each bar with respect to h
	const y = dataArray.map((val, ind) => { return h-val; });
	console.log("y: ", y);
	
	// ---------------------------------------------------

	// Asign the figure element on the page
	const svg = d3.select("#data_display")
		.append("svg")  // appends <svg tag> to each data value
		.attr('width', w)
		.attr('height', h);
	console.log("svg: ", svg);

	// ---------------------------------------------------
	
	// Assign the bar chart elements on the figure

	var dropdown_option_type = document.getElementById("dropdown_options").value;
	
	// width = bar_width of each bar
	// height = bar_height of each bar (using dataArray values)
	// x = the (x-location) of each bar with respect to w
	// y = the (y-location) of each bar with respect to h
	
	if (dropdown_option_type == 'drop_down_option0') {

		// Way 0: not using the scale command - did not work
		const bar_chart = svg.selectAll('rect')
			.data(dataArray)
			.enter()
			.append('rect')
			.attr('width', bar_width)
			.attr('height', d => d)
			.attr('x', (d, i) => i * w_divided_by_dataPoint_length)
			.attr('y', d => h-d)
			.attr("fill", "steelblue");

	} else if (dropdown_option_type == 'drop_down_option1') {
		
		// Way 1: using the scale command - did not work
		const x_scale = d3.scaleBand()
			.domain(dataArray.map((d,i) => i))
			.range([0, w])
			.padding(padding);

		const y_scale = d3.scaleLinear()
			.domain([0, max_val])
			.range([h, 0]);
		
		const bar_chart = svg.selectAll('rect')
			.data(dataArray)
			.enter()
			.append('rect')
			.attr('width', bar_width)
			.attr('height', d => y_scale(h-d))
			.attr('x', (d,i) => x_scale(i))
			.attr('y', (d,i) => y_scale(d))
			.attr("fill", "steelblue");

	} else if (dropdown_option_type == 'drop_down_option2') {
		
		// Way 2: Class recommendation
		const bar_chart = svg.selectAll('rect')
			.data(dataArray)
			.enter()
			.append('rect')
			.attr("y", function(d) { return h - d; })
			.attr("height", function(d) { return d; })
			.attr("width", bar_width - padding)
			.attr("fill", "steelblue")
			.attr("transform", function (d, i) { 
				var translate = [bar_width * i, 0]; 
				return "translate("+ translate +")";
			});

	}

	
}

// -----------------------------------------------
	
async function plot_line_graph_dataArray() {

	const dataArray = [30, 50, 80, 120, 200];

	const width = 928;
	const height = 500;

	var example = 2;

	if (example == 2) {
		
		// [Step 0] Specify the DOM item to assign the figure to
		// svg is a variable that can be used as a function, to add more specifications to d3
	        const svg = d3.select("#data_display")
			.append("svg")  // appends svg for each data element
			.attr("class", 'line')
			.attr("width", width)
			.attr("height", height);

	        const x_scale = d3.scaleLinear()
	            .domain([0, d3.max(dataArray, (d,i) => i)])
	            .range([0, width]);
	
	        const y_scale = d3.scaleLinear()
	            .domain([0, d3.max(dataArray, d => d)])
	            .range([height, 0]);
	
	        const line = d3.line()
			.x((d, i) => x_scale(i))
			.y(d => y_scale(d));
	
	        svg.append("path")
	            .datum(dataArray)
	            .attr("fill", "none")
	            .attr("stroke", "steelblue")
	            .attr("stroke-width", 2)
	            .attr("d", line);
	
		// Add the x-axis
		svg.append("g")
			.attr('class', 'x-axis')
			.call(d3.axisBottom(x_scale));
	
		// Add the y-axis
		svg.append("g")
			.attr('class', 'y-axis')
			.call(d3.axisLeft(y_scale));

	} 
	
}

// -----------------------------------------------
	
const w = 150;
	
async function plot_line_graph_dataObject() {

	const data = [
            { x: 0, y: 10 },
            { x: 1, y: 20 },
            { x: 2, y: 15 },
            { x: 3, y: 25 },
            { x: 4, y: 18 }
        ];

	const width = 928;
	const height = 500;
	// const margin = {top: 20, right: 20, bottom: 20, left: 20};
	
        const svg = d3.select("#data_display")
		.append("svg")
		.attr("class", 'line')
		.attr("width", width)
		.attr("height", height);

        const x_scale = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.x)])
            .range([0, width]);

        const y_scale = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.y)])
            .range([height, 0]);

        const line = d3.line()
            .x(d => x_scale(d.x))
            .y(d => y_scale(d.y));

        svg.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 2)
            .attr("d", line);

	// Add the x-axis
	svg.append("g")
		.attr('class', 'x-axis')
		.call(d3.axisBottom(x_scale));

	// Add the y-axis
	svg.append("g")
		.attr('class', 'y-axis')
		.call(d3.axisLeft(y_scale));
	
}

// -----------------------------------------------
	
async function plot_timeseries_data() {

	const dataArray = [30, 50, 80, 120, 200];

	// [Step 0] Verify timeseries signal characteristics
	const arr_char_ts = await obtain_array_characteristics(dataArray);
	console.log('arr_char_ts: ', arr_char_ts);
	
	// [Step 1] Create a canvas to plot timeseries data on
	const ctx = await create_dynamic_canvasElement(w);
	
	ctx.fillStyle = "rgb(200 200 200)"; 	// gray background
	const WIDTH = w;
	const HEIGHT = w;  // height of the canvas
	ctx.fillRect(0, 0, WIDTH, HEIGHT);
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgb(0 0 0)"; 	// black waveform line
	ctx.fillStyle = 'black';
	
	const time_step = WIDTH/dataArray.length;
	console.log('time_step: ', time_step);
	
	var x_scaled = 0;
	var y_normalized = 0;
	var y_scaled = 0;
	
	ctx.beginPath();
	for (let i = 0; i < dataArray.length; i++) {

		if (arr_char_ts.sigma == 0) {
			y_normalized = 0;
		} else {
			y_normalized = (dataArray_ts.at(i) - arr_char_ts.mu) / arr_char_ts.sigma; // [-1, 1]
		}
		// console.log('y_normalized:', y_normalized);
		
		y_scaled = y_normalized*(HEIGHT/2); // To make the line centered
		// console.log('y_scaled:', y_scaled);
		// console.log('x_scaled:', x_scaled);
		
		if (i === 0) {
			ctx.moveTo(x_scaled, y_scaled);
		} else {
			ctx.lineTo(x_scaled, y_scaled);
		}
		x_scaled = x_scaled + time_step;
	}
	ctx.stroke();
	
}

// -----------------------------------------------

async function obtain_array_characteristics(arr) {

	var arr_char = {};
	
	arr_char.mu = await mean(arr);
	arr_char.sigma = await std(arr);

	const arr_sort = arr.sort();
	arr_char.max_val = arr_sort.at(arr.length-1);
	arr_char.min_val = arr_sort.at(0);
	
	return arr_char;
}
	
// -----------------------------------------------

async function sum(arr) {
	return arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
}

// -----------------------------------------------
  
async function mean(arr) {
	return await sum(arr)/arr.length;
}

// -----------------------------------------------

async function std(arr) {
	const mu =  await mean(arr);
	console.log('mu: ', mu);

	var arr1 = arr.map((x) => { return x-mu; });
	const summ = await sum(arr1);
	console.log('summ: ', summ);

	const out = Math.sqrt( Math.pow(summ, 2)/arr.length );
	console.log('out: ', out);
	
	return out;
}
	
// -----------------------------------------------

async function create_dynamic_canvasElement(w) {

  	const index = 0;
  
	// Create a canvas element
	var canvasElement = document.createElement('canvas');

	// Set the width and height of the canvas
	canvasElement.width = w;
	canvasElement.height = canvasElement.width;
	      
	// Get the 2D rendering context of the canvas
	var ctx = canvasElement.getContext("2d");
	
	if (index == 0) {
		canvasElement.style.left = 40+'px';
	} else {
		let tot = index*canvasElement.width + 40;
		canvasElement.style.left = tot+'px';
	}
	
	// Add the canvas to the document body or any other desired element
	document.getElementById('data_display').appendChild(canvasElement);

	return ctx;
}


</script>

  
</body>
</html>
