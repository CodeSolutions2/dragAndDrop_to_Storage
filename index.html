<!DOCTYPE html>
<html>
<head></head>
<body>

<button id="plot_line_graph_dataObject" onclick="plot_line_graph_dataObject()" style="display:block;">plot_line_graph_dataObject</button>
<button id="plot_line_graph_dataArray" onclick="plot_line_graph_dataArray()" style="display:block;">plot_line_graph_dataArray</button>
<button id="plot_timeseries_data" onclick="plot_timeseries_data()" style="display:block;">plot_timeseries_data</button>


<div id="data_display" style="display:block; text-align: left; width: 600px;"></div>
	

<script src='https://d3js.org/d3.v7.min.js'></script>


<script>

const w = 150;
	
async function plot_line_graph_dataObject() {

	const data = [
            { x: 0, y: 10 },
            { x: 1, y: 20 },
            { x: 2, y: 15 },
            { x: 3, y: 25 },
            { x: 4, y: 18 }
        ];

	const width = 928;
	const height = 500;
	// const margin = {top: 20, right: 20, bottom: 20, left: 20};
	
        const svg = d3.select("#data_display")
		.append("svg")
		.attr("class", 'line')
		.attr("width", width)
		.attr("height", height);

        const x_scale = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.x)])
            .range([0, width]);

        const y_scale = d3.scaleLinear()
            .domain([0, d3.max(data, d => d.y)])
            .range([height, 0]);

        const line = d3.line()
            .x(d => x_scale(d.x))
            .y(d => y_scale(d.y));

        svg.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 2)
            .attr("d", line);

	// Add the x-axis
	svg.append("g")
		.attr('class', 'x-axis')
		.call(d3.axisBottom(x_scale));

	// Add the y-axis
	svg.append("g")
		.attr('class', 'y-axis')
		.call(d3.axisLeft(y_scale));
	
}

async function plot_line_graph_dataArray() {

	const dataArray = [30, 50, 80, 120, 200];

	const width = 928;
	const height = 500;

        const svg = d3.select("#data_display")
		.append("svg")
		.attr("class", 'line')
		.attr("width", width)
		.attr("height", height);

        const x_scale = d3.scaleLinear()
            .domain([0, d3.max(dataArray, (d,i) => i)])
            .range([0, width]);

        const y_scale = d3.scaleLinear()
            .domain([0, d3.max(dataArray, d => d)])
            .range([height, 0]);

        const line = d3.line()
		.x((d, i) => x_scale(i))
		.y(d => y_scale(d));

        svg.append("path")
            .datum(dataArray)
            .attr("fill", "none")
            .attr("stroke", "steelblue")
            .attr("stroke-width", 2)
            .attr("d", line);

	// Add the x-axis
	svg.append("g")
		.attr('class', 'x-axis')
		.call(d3.axisBottom(x_scale));

	// Add the y-axis
	svg.append("g")
		.attr('class', 'y-axis')
		.call(d3.axisLeft(y_scale));
}

// -----------------------------------------------
	
async function plot_timeseries_data() {

	const dataArray = [30, 50, 80, 120, 200];

	// [Step 0] Verify timeseries signal characteristics
	const arr_char_ts = await obtain_array_characteristics(dataArray);
	console.log('arr_char_ts: ', arr_char_ts);
	
	// [Step 1] Create a canvas to plot timeseries data on
	const ctx = await create_dynamic_canvasElement(w);
	
	ctx.fillStyle = "rgb(200 200 200)"; 	// gray background
	const WIDTH = w;
	const HEIGHT = w;  // height of the canvas
	ctx.fillRect(0, 0, WIDTH, HEIGHT);
	ctx.lineWidth = 2;
	ctx.strokeStyle = "rgb(0 0 0)"; 	// black waveform line
	ctx.fillStyle = 'black';
	
	const time_step = WIDTH/dataArray.length;
	console.log('time_step: ', time_step);
	
	var x_scaled = 0;
	var y_normalized = 0;
	var y_scaled = 0;
	
	ctx.beginPath();
	for (let i = 0; i < dataArray.length; i++) {

		if (arr_char_ts.sigma == 0) {
			y_normalized = 0;
		} else {
			y_normalized = (dataArray_ts.at(i) - arr_char_ts.mu) / arr_char_ts.sigma; // [-1, 1]
		}
		// console.log('y_normalized:', y_normalized);
		
		y_scaled = y_normalized*(HEIGHT/2); // To make the line centered
		// console.log('y_scaled:', y_scaled);
		// console.log('x_scaled:', x_scaled);
		
		if (i === 0) {
			ctx.moveTo(x_scaled, y_scaled);
		} else {
			ctx.lineTo(x_scaled, y_scaled);
		}
		x_scaled = x_scaled + time_step;
	}
	ctx.stroke();
	
}

// -----------------------------------------------

async function obtain_array_characteristics(arr) {

	var arr_char = {};
	
	arr_char.mu = await mean(arr);
	arr_char.sigma = await std(arr);

	const arr_sort = arr.sort();
	arr_char.max_val = arr_sort.at(arr.length-1);
	arr_char.min_val = arr_sort.at(0);
	
	return arr_char;
}
	
// -----------------------------------------------

async function sum(arr) {
	return arr.reduce((accumulator, currentValue) => accumulator + currentValue, 0);
}

// -----------------------------------------------
  
async function mean(arr) {
	return await sum(arr)/arr.length;
}

// -----------------------------------------------

async function std(arr) {
	const mu =  await mean(arr);
	console.log('mu: ', mu);

	var arr1 = arr.map((x) => { return x-mu; });
	const summ = await sum(arr1);
	console.log('summ: ', summ);

	const out = Math.sqrt( Math.pow(summ, 2)/arr.length );
	console.log('out: ', out);
	
	return out;
}
	
// -----------------------------------------------

async function create_dynamic_canvasElement(w) {

  	const index = 0;
  
	// Create a canvas element
	var canvasElement = document.createElement('canvas');

	// Set the width and height of the canvas
	canvasElement.width = w;
	canvasElement.height = canvasElement.width;
	      
	// Get the 2D rendering context of the canvas
	var ctx = canvasElement.getContext("2d");
	
	if (index == 0) {
		canvasElement.style.left = 40+'px';
	} else {
		let tot = index*canvasElement.width + 40;
		canvasElement.style.left = tot+'px';
	}
	
	// Add the canvas to the document body or any other desired element
	document.getElementById('data_display').appendChild(canvasElement);

	return ctx;
}


</script>

  
</body>
</html>
